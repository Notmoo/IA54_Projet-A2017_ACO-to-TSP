package com.utbm.ia54.aco

import com.utbm.ia54.aco.java.ArrayFactory
import java.util.Random
import io.sarl.core.DefaultContextInteractions
import java.util.UUID

/* ---------------------------
 * CAPACITIES
 * ---------------------------
 */
capacity TSPPathFinder{
	def findPath(nbNodes : short, env : float[][][], idFirstNode : short, idLastNode : short) : TspPath
}

/* ---------------------------
 * SKILLS
 * ---------------------------
 */
skill SimpleTSPPathFinder implements TSPPathFinder {
	uses DefaultContextInteractions
	
	var envUUID : UUID
	
	//TODO add a while loop in case of end without finding a suitable solution (e.g. when graph is not complete and not all nodes are visited before running out of paths)
	def findPath(nbNodes : short, env : float[][][], idFirstNode : short, idLastNode : short) : TspPath {
		var visited = ArrayFactory.newBooleanArray(nbNodes)
		var solution = ArrayFactory.newShortArray(nbNodes)
		var step : int
		var dist : double = 0
		
		solution.set(0, idFirstNode)
		
		for(step = 1; step < nbNodes; step++){
			var temp_node_id : short = (-1) as short
			
			do{
				if(step === nbNodes-1 && idLastNode!=-1){
					temp_node_id = idLastNode
				}else{
					temp_node_id = findNext(nbNodes, computeProbabilities(nbNodes, env.get(solution.get(step-1)), visited, idLastNode))
				}
			}while(temp_node_id===-1)
			dist += env.get(solution.get(step - 1)).get(temp_node_id).get(0)
		}
		
		return new TspPath(nbNodes, solution, dist)
	}
	
	def computeProbabilities (nbNodes : short, destinations : float[][], visited : boolean[], idLastNode : short) : double[] {
		var nbNoeudEligibles : int = 0
		var totalPheromones : double = 0
		var proba : double[] = ArrayFactory.newDoubleArray(nbNodes);
		
		var i : int
		
		for(i = 0; i< nbNodes; i++){
			if(!visited.get(i) && i!==idLastNode){
				nbNoeudEligibles++
				totalPheromones+=destinations.get(i).get(1)
			}
		}
		
		for (i = 0; i < nbNodes; i++) {
			if(!visited.get(i) && i !== idLastNode){
				if(i === 0)
					proba.set(i, destinations.get(i).get(1)/totalPheromones)
				else
					proba.set(i, proba.get(i) + destinations.get(i).get(1) / totalPheromones)
			}else if(i === 0){
				proba.set(0, 0)
			}else{
				proba.set(i, proba.get(i-1))
			}
		}
		
		return proba
	}
	
	def findNext(nbNodes : short, proba : double[]) : short {
		var id : short = 0 as short
		id--
		val rand = new Random().nextDouble
		var i : short = 0 as short
		
		while(rand>=proba.get(i))
			i++
		
		if(rand<proba.get(i))
			id = i
		
		return id
	}

	on IterationStart {
		if (occurrence.idFirstNode != -1) {
			findPath(occurrence.nbNodes, occurrence.env, occurrence.idFirstNode, occurrence.idLastNode).emit[
				it.getUUID === envUUID
			]
			new AntFinished().emit[it.getUUID === occurrence.source.getUUID]
		} else {
			val idFirstNode : short = (new Random().nextInt(occurrence.nbNodes - 1) + 1) as short
			findPath(occurrence.nbNodes, occurrence.env, idFirstNode, occurrence.idLastNode).emit [
				it.getUUID === envUUID
			]
			new AntFinished().emit[it.getUUID === occurrence.source.getUUID]
		}
	}
	
	on AntCreatedAck {
		envUUID = occurrence.source.UUID	
	}
}

skill BottleneckTSPPathFinder implements TSPPathFinder{
	uses SimpleTSPPathFinder

	// TODO add a while loop in case of end without finding a suitable solution (e.g. when graph is not complete and not all nodes are visited before running out of paths)
	@Override
	def findPath(nbNodes : short, env : float[][][], idFirstNode : short, idLastNode : short) : TspPath {
		var visited = ArrayFactory.newBooleanArray(nbNodes)
		var solution = ArrayFactory.newShortArray(nbNodes)
		var step : int
		var dist : double = 0

		solution.set(0, idFirstNode)

		for (step = 1; step < nbNodes; step++) {
			var temp_node_id : short = (-1) as short
			
			do {
				if (step === nbNodes - 1 && idLastNode != -1) {
					temp_node_id = idLastNode
				} else {
					temp_node_id = findNext(nbNodes,
						computeProbabilities(nbNodes, env.get(solution.get(step - 1)), visited, idLastNode))
				}
			} while (temp_node_id === -1)
			val temp_dist = env.get(solution.get(step - 1)).get(temp_node_id).get(0)
			if(temp_dist<dist)
				dist = temp_dist
		}

		return new TspPath(nbNodes, solution, dist)
	}
	
}