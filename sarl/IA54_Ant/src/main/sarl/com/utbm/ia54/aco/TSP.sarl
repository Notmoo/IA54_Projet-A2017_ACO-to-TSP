package com.utbm.ia54.aco

import com.utbm.ia54.aco.java.ArrayFactory
import java.util.Random

/* ---------------------------
 * EVENTS
 * ---------------------------
 */
event tsp_path {
	val nbNodes : short
	val nodes : short[]
	val dist : double
	
	new(nbNodes : short, nodes : short[], dist : double) {
		this.nbNodes = nbNodes
		this.nodes = nodes
		this.dist = dist
	}
}

/* ---------------------------
 * CAPACITIES
 * ---------------------------
 */
capacity TSPPathFinder{
	def findPath(nbNodes : short, env : float[][][], idFirstNode : short, idLastNode : short) : tsp_path
}

/* ---------------------------
 * SKILLS
 * ---------------------------
 */
skill SimpleTSPPathFinder implements TSPPathFinder {
	
	//TODO add a while loop in case of end without finding a suitable solution (e.g. when graph is not complete and not all nodes are visited before running out of paths)
	def findPath(nbNodes : short, env : float[][][], idFirstNode : short, idLastNode : short) : tsp_path {
		var visited = ArrayFactory.newBooleanArray(nbNodes)
		var solution = ArrayFactory.newShortArray(nbNodes)
		var step : int
		var dist : double = 0
		
		solution.set(0, idFirstNode)
		
		for(step = 1; step < nbNodes; step++){
			var temp_node_id : short = (-1) as short
			
			do{
				if(step === nbNodes-1 && idLastNode!=-1){
					temp_node_id = idLastNode
				}else{
					temp_node_id = findNext(nbNodes, computeProbabilities(nbNodes, env.get(solution.get(step-1)), visited, idLastNode))
				}
			}while(temp_node_id===-1)
			dist += env.get(solution.get(step - 1)).get(temp_node_id).get(0)
		}
		
		return new tsp_path(nbNodes, solution, dist)
	}
	
	def computeProbabilities (nbNodes : short, destinations : float[][], visited : boolean[], idLastNode : short) : double[] {
		var nbNoeudEligibles : int = 0
		var totalPheromones : double = 0
		var proba : double[] = ArrayFactory.newDoubleArray(nbNodes);
		
		var i : int
		
		for(i = 0; i< nbNodes; i++){
			if(!visited.get(i) && i!==idLastNode){
				nbNoeudEligibles++
				totalPheromones+=destinations.get(i).get(1)
			}
		}
		
		for (i = 0; i < nbNodes; i++) {
			if(!visited.get(i) && i !== idLastNode){
				if(i === 0)
					proba.set(i, destinations.get(i).get(1)/totalPheromones)
				else
					proba.set(i, proba.get(i) + destinations.get(i).get(1) / totalPheromones)
			}else if(i === 0){
				proba.set(0, 0)
			}else{
				proba.set(i, proba.get(i-1))
			}
		}
		
		return proba
	}
	
	def findNext(nbNodes : short, proba : double[]) : short {
		var id : short = 0 as short
		id--
		val rand = new Random().nextDouble
		var i : short = 0 as short
		
		while(rand>=proba.get(i))
			i++
		
		if(rand<proba.get(i))
			id = i
		
		return id
	}
	
}