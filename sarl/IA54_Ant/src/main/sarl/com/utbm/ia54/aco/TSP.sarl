package com.utbm.ia54.aco

import com.utbm.ia54.aco.java.ArrayFactory
import java.util.Random
import io.sarl.core.DefaultContextInteractions
import java.util.UUID
import io.sarl.core.Initialize
import java.util.Map
import java.util.List

/* ---------------------------
 * BEHAVIORS
 * ---------------------------
 */
 abstract behavior TSPWorker{

	protected var envUUID : UUID

	on AntCreatedAck {
		envUUID = occurrence.source.UUID
	}
 }
 
 behavior ClassicTSPWorker extends TSPWorker{
	uses DefaultContextInteractions, TSPPathFinder
	
	var currTspVersion : int
	
	on Initialize{
		currTspVersion = 0
		new SimpleTSPPathFinder().setSkill(TSPPathFinder)
	}

	on SimpleIterationStart {
		if (occurrence.idFirstNode != -1) {
			findPath(occurrence.nbNodes, occurrence.env, occurrence.idFirstNode, occurrence.idLastNode).emit [
				it.getUUID === envUUID
			]
			new AntFinished().emit[it.getUUID === occurrence.source.getUUID]
		} else {
			val idFirstNode : short = (new Random().nextInt(occurrence.nbNodes - 1) + 1) as short
			findPath(occurrence.nbNodes, occurrence.env, idFirstNode, occurrence.idLastNode).emit [
				it.getUUID === envUUID
			]
			new AntFinished().emit[it.getUUID === occurrence.source.getUUID]
		}
	}
	
	on ChangeTspVersion {
		if (occurrence.version_nb === 0 && currTspVersion!==occurrence.version_nb) {
			new SimpleTSPPathFinder().setSkill(TSPPathFinder)

			currTspVersion = occurrence.version_nb
		}
		if (occurrence.version_nb === 1 && currTspVersion !== occurrence.version_nb) {
			new BottleneckTSPPathFinder().setSkill(TSPPathFinder)

			currTspVersion = occurrence.version_nb
		}
	}
 }
 
 behavior TWTSPWorker extends TSPWorker {
	uses DefaultContextInteractions, TWTSPPathFinder

	on Initialize {
		new TimeWindowTSPPathFinder().setSkill(TWTSPPathFinder)
	}

	on TWIterationStart {
		if (occurrence.idFirstNode != -1) {
			findPath(occurrence.nbNodes, occurrence.env, occurrence.idFirstNode, occurrence.idLastNode, occurrence.timeWindows,
				occurrence.initialTimeStamp).emit [
				it.getUUID === envUUID
			]
			new AntFinished().emit[it.getUUID === occurrence.source.getUUID]
		} else {
			val idFirstNode : short = (new Random().nextInt(occurrence.nbNodes - 1) + 1) as short
			findPath(occurrence.nbNodes, occurrence.env, idFirstNode, occurrence.idLastNode, occurrence.timeWindows,
				occurrence.initialTimeStamp).emit [
				it.getUUID === envUUID
			]
			new AntFinished().emit[it.getUUID === occurrence.source.getUUID]
		}
	}
 }


/* ---------------------------
 * CAPACITIES
 * ---------------------------
 */
capacity TSPPathFinder{
	def findPath(nbNodes : short, env : float[][][], idFirstNode : short, idLastNode : short) : TspPath
}

capacity TWTSPPathFinder {
	def findPath(nbNodes : short, env : float[][][], idFirstNode : short, idLastNode : short,
		timeWindows : Map<Short, List<Pair<Float, Float>>>, initialTimeStamp : float) : TspPath
}

/* ---------------------------
 * SKILLS
 * ---------------------------
 */
skill SimpleTSPPathFinder implements TSPPathFinder {
	
	//TODO add a while loop in case of end without finding a suitable solution (e.g. when graph is not complete and not all nodes are visited before running out of paths)
	def findPath(nbNodes : short, env : float[][][], idFirstNode : short, idLastNode : short) : TspPath {
		var visited = ArrayFactory.newBooleanArray(nbNodes)
		var solution = ArrayFactory.newShortArray(nbNodes)
		var step : int
		var dist : double = 0
		
		solution.set(0, idFirstNode)
		
		for(step = 1; step < nbNodes; step++){
			var temp_node_id : short = (-1) as short
			
			do{
				if(step === nbNodes-1 && idLastNode!=-1){
					temp_node_id = idLastNode
				}else{
					temp_node_id = findNext(nbNodes, computeProbabilities(nbNodes, env.get(solution.get(step-1)), visited, idLastNode))
				}
			}while(temp_node_id===-1)
			dist += env.get(solution.get(step - 1)).get(temp_node_id).get(0)
		}
		
		return new TspPath(nbNodes, solution, dist)
	}
	
	def computeProbabilities (nbNodes : short, destinations : float[][], visited : boolean[], idLastNode : short) : double[] {
		var nbNoeudEligibles : int = 0
		var totalPheromones : double = 0
		var proba : double[] = ArrayFactory.newDoubleArray(nbNodes);
		
		var i : int
		
		for(i = 0; i< nbNodes; i++){
			if(!visited.get(i) && i!==idLastNode){
				nbNoeudEligibles++
				totalPheromones+=destinations.get(i).get(1)
			}
		}
		
		for (i = 0; i < nbNodes; i++) {
			if(!visited.get(i) && i !== idLastNode){
				if(i === 0)
					proba.set(i, destinations.get(i).get(1)/totalPheromones)
				else
					proba.set(i, proba.get(i) + destinations.get(i).get(1) / totalPheromones)
			}else if(i === 0){
				proba.set(0, 0)
			}else{
				proba.set(i, proba.get(i-1))
			}
		}
		
		return proba
	}
	
	def findNext(nbNodes : short, proba : double[]) : short {
		var id : short = 0 as short
		id--
		val rand = new Random().nextDouble
		var i : short = 0 as short
		
		while(rand>=proba.get(i))
			i++
		
		if(rand<proba.get(i))
			id = i
		
		return id
	}
}

skill BottleneckTSPPathFinder implements TSPPathFinder{
	uses SimpleTSPPathFinder

	// TODO add a while loop in case of end without finding a suitable solution (e.g. when graph is not complete and not all nodes are visited before running out of paths)
	def findPath(nbNodes : short, env : float[][][], idFirstNode : short, idLastNode : short) : TspPath {
		var visited = ArrayFactory.newBooleanArray(nbNodes)
		var solution = ArrayFactory.newShortArray(nbNodes)
		var step : int
		var dist : double = 0

		solution.set(0, idFirstNode)

		for (step = 1; step < nbNodes; step++) {
			var temp_node_id : short = (-1) as short
			
			do {
				if (step === nbNodes - 1 && idLastNode != -1) {
					temp_node_id = idLastNode
				} else {
					temp_node_id = findNext(nbNodes,
						computeProbabilities(nbNodes, env.get(solution.get(step - 1)), visited, idLastNode))
				}
			} while (temp_node_id === -1)
			val temp_dist = env.get(solution.get(step - 1)).get(temp_node_id).get(0)
			if(temp_dist<dist)
				dist = temp_dist
		}

		return new TspPath(nbNodes, solution, dist)
	}	
}

skill TimeWindowTSPPathFinder implements TWTSPPathFinder{
	
	def findPath(nbNodes : short, env : float[][][], idFirstNode : short, idLastNode : short,
		timeWindows : Map<Short, List<Pair<Float, Float>>>,
		initialTimeStamp : float) : TspPath {
		var visited = ArrayFactory.newBooleanArray(nbNodes)
		var solution = ArrayFactory.newShortArray(nbNodes)
		var step : int
		var dist : double = 0
		var actualTimeStamp = initialTimeStamp

		solution.set(0, idFirstNode)

		for (step = 1; step < nbNodes; step++) {
			var temp_node_id : short = (-1) as short

			do {
				if (step === nbNodes - 1 && idLastNode != -1) {
					temp_node_id = idLastNode
				} else {
					temp_node_id = findNext(nbNodes,
						computeProbabilities(nbNodes, env.get(solution.get(step - 1)), visited, idLastNode, timeWindows, actualTimeStamp))
				}
			} while (temp_node_id === -1)
			val temp_dist = env.get(solution.get(step - 1)).get(temp_node_id).get(0)
			actualTimeStamp += temp_dist
			dist += temp_dist
		}

		return new TspPath(nbNodes, solution, dist)
	}

	def computeProbabilities(nbNodes : short, destinations : float[][], visited : boolean[],
		idLastNode : short, timeWindows : Map<Short, List<Pair<Float, Float>>>, timeStamp : float) : double[] {
		var nbNoeudEligibles : int = 0
		var totalPheromones : double = 0
		var proba : double[] = ArrayFactory.newDoubleArray(nbNodes);

		var i : int

		for (i = 0; i < nbNodes; i++) {
			if(!visited.get(i) && i !== idLastNode){
				var timeWindowOK = false
				for (var indexPair : int = 0; indexPair < timeWindows.get(i).size; indexPair++) {
					if(timeWindows.get(i).get(indexPair).key <= timeStamp
						&& timeWindows.get(i).get(indexPair).value > timeStamp
					){
						timeWindowOK = true
					}
				}
				
				//Clause if en dehors de la boucle pour limiter la vérification à une par noeud
				//Plusieurs clauses auraient pu être validées si les time windows d'un noeud se supperposent et sont valides en même temps
				if (timeWindowOK) {
					nbNoeudEligibles++
					totalPheromones += destinations.get(i).get(1)
				}
			}
		}

		for (i = 0; i < nbNodes; i++) {
			if (!visited.get(i) && i !== idLastNode) {
				if (i === 0)
					proba.set(i, destinations.get(i).get(1) / totalPheromones)
				else
					proba.set(i, proba.get(i) + destinations.get(i).get(1) / totalPheromones)
			} else if (i === 0) {
				proba.set(0, 0)
			} else {
				proba.set(i, proba.get(i - 1))
			}
		}

		return proba
	}

	def findNext(nbNodes : short, proba : double[]) : short {
		var id : short = 0 as short
		id--
		val rand = new Random().nextDouble
		var i : short = 0 as short

		while (rand >= proba.get(i))
			i++

		if (rand < proba.get(i))
			id = i

		return id
	}	
}